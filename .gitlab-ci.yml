# .gitlab-ci.yml
variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  KUBECONFIG: /tmp/kubeconfig
  KUBECONTEXT: "gke_theta-moment-469209-j0_asia-southeast1_autopilot-cluster-1"
  KUBE_NAMESPACE: "production"
  DOMAIN: "ecommerce.bunlong.site"
  MSSQL_PASSWORD: "YourStrong@Password123!"
  MSSQL_DB: "Ecommerce"

stages:
  - build
  - database
  # - deploy

# Build and Push Docker Image
build:
  stage: build
  image: docker:28.3.3
  services:
    - docker:28.3.3-dind
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    # Update appsettings.json with production connection string
    - sed -i 's|Server=server|Server=mssql-service,1433;Database=Ecommerce;User Id=sa;Password=YourStrong@Password123!;TrustServerCertificate=True;|g' appsettings.json
    
    # Verify the connection string was updated
    - cat appsettings.json | grep "DefaultConnection"  

    # . at then end: is used the current directory to look for the Dockerfile
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA -t $CI_REGISTRY_IMAGE:latest .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
  only:
    - main
    - develop

# Database Setup using kubectl exec
setup_database:
  stage: database
  image: google/cloud-sdk:alpine
  before_script:
    - echo $KUBE_CONFIG | base64 -d > $KUBECONFIG
    - kubectl config use-context $KUBECONTEXT
    - kubectl cluster-info
  script:
    # Wait for SQL Server to be ready
    - echo "Waiting for SQL Server to be ready..."
    - kubectl wait --for=condition=ready pod -l app=mssql -n production --timeout=300s
    
    # Get the SQL Server pod name
    - MSSQL_POD=$(kubectl get pods -l app=mssql -n production -o jsonpath='{.items[0].metadata.name}')
    - echo "SQL Server pod: $MSSQL_POD"

    # Test connection first (using the correct sqlcmd path for SQL Server 2022)
    - kubectl exec $MSSQL_POD -n $KUBE_NAMESPACE -- /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P "$MSSQL_PASSWORD" -Q "SELECT @@VERSION" -C
    
    # Create database if not exists
    - |
      kubectl exec $MSSQL_POD -n production -- /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P "$MSSQL_PASSWORD" -C -Q "
      IF NOT EXISTS (SELECT name FROM sys.databases WHERE name = '$MSSQL_DB')
      BEGIN
          CREATE DATABASE [$MSSQL_DB];
          PRINT 'Database $MSSQL_DB created successfully.';
      END
      ELSE
      BEGIN
          PRINT 'Database $MSSQL_DB already exists.';
      END"
    
    # Verify database creation
    - kubectl exec $MSSQL_POD -n production -- /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P "$MSSQL_PASSWORD" -Q "SELECT name FROM sys.databases WHERE name = '$MSSQL_DB';" -C
  environment:
    name: $KUBE_NAMESPACE
  when: manual
  only:
    - main
  needs: []

# Database Migration with EF Core
migrate_database:
  stage: database
  image: google/cloud-sdk:alpine
  before_script:
    - echo $KUBE_CONFIG | base64 -d > $KUBECONFIG
    - kubectl config use-context $KUBECONTEXT
    - kubectl cluster-info
    
    # Install .NET SDK in Alpine
    - apk add --no-cache wget
    - wget https://dot.net/v1/dotnet-install.sh
    - chmod +x dotnet-install.sh
    - ./dotnet-install.sh --channel 9.0 --install-dir /usr/share/dotnet
    - ln -s /usr/share/dotnet/dotnet /usr/local/bin/dotnet
    
    # Install EF Core tools
    - dotnet tool install --global dotnet-ef
    - export PATH="$PATH:/root/.dotnet/tools"
  script:
    # Wait for SQL Server to be ready
    - echo "Waiting for SQL Server to be ready..."
    - kubectl wait --for=condition=ready pod -l app=mssql -n $KUBE_NAMESPACE --timeout=300s
    
    # Use port-forward to connect to SQL Server securely
    - echo "Setting up port-forward to SQL Server..."
    - kubectl port-forward svc/mssql-service 1433:1433 -n $KUBE_NAMESPACE &
    - PORT_FORWARD_PID=$!
    - sleep 10  # Wait for port-forward to establish
    
    # Build connection string for localhost (via port-forward)
    - MIGRATION_CONNECTION_STRING="Server=localhost,1433;Database=$MSSQL_DB;User Id=sa;Password=$MSSQL_PASSWORD;TrustServerCertificate=True;Encrypt=True;"
    - echo "Using connection string (password hidden): Server=localhost,1433;Database=$MSSQL_DB;User Id=sa;Password=***;TrustServerCertificate=True;Encrypt=True;"
    
    # Test connection
    - echo "Testing database connection..."
    - timeout 30 sh -c 'until nc -z localhost 1433; do sleep 2; done' || echo "Warning: Connection test failed, proceeding anyway"
    
    # Copy project files if needed (assuming they're in the working directory)
    - echo "Current directory contents:"
    - ls -la
    
    # List available migrations
    - echo "Available migrations:"
    - dotnet ef migrations list --connection "$MIGRATION_CONNECTION_STRING" || echo "No migrations found or connection failed"
    
    # Run EF migrations
    - echo "Running EF Core migrations..."
    - dotnet ef database update --connection "$MIGRATION_CONNECTION_STRING" --verbose
    
    # Clean up port-forward
    - kill $PORT_FORWARD_PID || true
    
    # Verify migration success
    - echo "Migration completed successfully!"
  when: manual
  only:
    - main
  environment:
    name: $KUBE_NAMESPACE
  needs:
    - setup_database

# # Deploy to Kubernetes
# deploy_production:
#   stage: deploy
#   image: bitnami/kubectl:latest
#   before_script:
#     - echo $KUBE_CONFIG | base64 -d > $KUBECONFIG
#     - kubectl config use-context $KUBECONTEXT
#   script:
#     # Update image tag in ArgoCD application manifest
#     - kubectl patch application aspnet-ecommerce -n argocd --type='merge' -p='{"spec":{"source":{"helm":{"parameters":[{"name":"image.repository","value":"'$CI_REGISTRY_IMAGE'"},{"name":"image.tag","value":"'$CI_COMMIT_SHA'"}]}}}}'
    
#     # Trigger ArgoCD sync (optional - ArgoCD can auto-sync)
#     - kubectl patch application aspnet-ecommerce -n argocd --type='merge' -p='{"operation":{"sync":{"revision":"HEAD"}}}'
    
#     # Wait for sync to complete
#     - kubectl wait --for=condition=Synced application/aspnet-ecommerce -n argocd --timeout=300s
    
#     # Verify deployment in production namespace
#     - kubectl get pods -n production -l app=aspnet-app

#     # Check TLS certificate status
#     - kubectl get certificate -n production
#     - kubectl describe certificate aspnet-tls-secret -n production

#     # Display service URLs
#     - echo "ðŸ“± API Base URL: https://$DOMAIN"
#     - echo "ðŸ“– Swagger UI: https://$DOMAIN/swagger"
#     - echo "ðŸ”’ TLS Certificate: $(kubectl get certificate aspnet-tls-secret -n production -o jsonpath='{.status.conditions[0].status}')"
#   environment:
#     name: $KUBE_NAMESPACE
#     url: https://$DOMAIN
#   when: manual
#   only:
#     - main