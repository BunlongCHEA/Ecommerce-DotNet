# .gitlab-ci.yml
variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  # KUBECONFIG: /tmp/kubeconfig
  KUBECONTEXT: "gke_theta-moment-469209-j0_asia-southeast1_autopilot-cluster-1"
  KUBE_NAMESPACE: "production"
  DOMAIN: "ecommerceapi.bunlong.site"
  # GKE Configuration
  GCP_PROJECT_ID: "theta-moment-469209-j0"
  GKE_CLUSTER_NAME: "autopilot-cluster-1"
  GKE_CLUSTER_ZONE: "asia-southeast1"
  # Email API Key
  EMAIL_FROMEMAIL: "sendgrid@bunlong.site"

stages:
  - build
  # - deploy

# Build and Push Docker Image
build:
  stage: build
  image: docker:28.3.3
  services:
    - docker:28.3.3-dind
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - echo "SENDGRID_API_KEY = $EMAIL_API"
  script:
    # Update appsettings.json with production connection string
    - sed -i 's|Server=DESKTOP-CQSN3MN\\SQLSERVERDEV2022;Database=Ecommerce;User Id=sa;Password=12345;TrustServerCertificate=True|Server=mssql-service,1433;Database=Ecommerce;User Id=sa;Password=YourStrong@Password123!;TrustServerCertificate=True|g' appsettings.json

    - sed -i 's|mongodb+srv://cbunlong168_db_user:ooyZ1lqtgsz27dPG@clusterlocal.12eysnm.mongodb.net/?retryWrites=true&w=majority&appName=ClusterLocal|mongodb://admin:RootPassword123@mongodb-service.production.svc.cluster.local:27017/MongoDB?authSource=admin|g' appsettings.json

    - sed -i 's|SendGrid_API_Key|$EMAIL_API|g' appsettings.json
    - sed -i 's|SendGrid_FromEmail|$EMAIL_FROMEMAIL|g' appsettings.json

    - sed -i 's|ecommercevue.bunlong.site|ecommercevue.bunlong.site|g' Program.cs
    - sed -i 's|ecommerceapi.bunlong.site|ecommerceapi.bunlong.site|g' Program.cs

    # Verify the connection string was updated
    - cat appsettings.json

    # . at then end: is used the current directory to look for the Dockerfile
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA -t $CI_REGISTRY_IMAGE:latest .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
  only:
    - main
    - develop

# # Deploy to Kubernetes
# deploy_production:
#   stage: deploy
#   image: bitnami/kubectl:latest
#   before_script:
#     - echo $KUBE_CONFIG | base64 -d > $KUBECONFIG
#     - kubectl config use-context $KUBECONTEXT
#   script:
#     # Update image tag in ArgoCD application manifest
#     - kubectl patch application aspnet-ecommerce -n argocd --type='merge' -p='{"spec":{"source":{"helm":{"parameters":[{"name":"image.repository","value":"'$CI_REGISTRY_IMAGE'"},{"name":"image.tag","value":"'$CI_COMMIT_SHA'"}]}}}}'
    
#     # Trigger ArgoCD sync (optional - ArgoCD can auto-sync)
#     - kubectl patch application aspnet-ecommerce -n argocd --type='merge' -p='{"operation":{"sync":{"revision":"HEAD"}}}'
    
#     # Wait for sync to complete
#     - kubectl wait --for=condition=Synced application/aspnet-ecommerce -n argocd --timeout=300s
    
#     # Verify deployment in $KUBE_NAMESPACE namespace
#     - kubectl get pods -n $KUBE_NAMESPACE -l app=aspnet-app

#     # Check TLS certificate status
#     - kubectl get certificate -n $KUBE_NAMESPACE
#     - kubectl describe certificate aspnet-tls-secret -n $KUBE_NAMESPACE

#     # Display service URLs
#     - echo "ðŸ“± API Base URL: https://$DOMAIN"
#     - echo "ðŸ“– Swagger UI: https://$DOMAIN/swagger"
#     - echo "ðŸ”’ TLS Certificate: $(kubectl get certificate aspnet-tls-secret -n $KUBE_NAMESPACE -o jsonpath='{.status.conditions[0].status}')"
#   environment:
#     name: $KUBE_NAMESPACE
#     url: https://$DOMAIN
#   when: manual
#   only:
#     - main