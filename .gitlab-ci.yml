# .gitlab-ci.yml
variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  KUBECONFIG: /tmp/kubeconfig
  KUBECONTEXT: "gke_theta-moment-469209-j0_asia-southeast1_autopilot-cluster-1"
  KUBE_NAMESPACE: "production"
  DOMAIN: "ecommerce.bunlong.site"
  MSSQL_PASSWORD: "YourStrong@Password123!"
  MSSQL_DB: "Ecommerce"

stages:
  - build
  - database
  # - deploy

# Build and Push Docker Image
build:
  stage: build
  image: docker:28.3.3
  services:
    - docker:28.3.3-dind
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    # Update appsettings.json with production connection string
    - sed -i 's|Server=34.124.219.191,1433;Database=Ecommerce;User Id=sa;Password=YourStrong@Password123!;TrustServerCertificate=True|Server=mssql-service,1433;Database=Ecommerce;User Id=sa;Password=YourStrong@Password123!;TrustServerCertificate=True;|g' appsettings.json

    # Verify the connection string was updated
    - cat appsettings.json | grep "DefaultConnection"

    # . at then end: is used the current directory to look for the Dockerfile
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA -t $CI_REGISTRY_IMAGE:latest .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
  only:
    - main
    - develop

# Database Setup using kubectl exec
setup_database:
  stage: database
  image: bitnami/kubectl:latest
  before_script:
    - echo $KUBE_CONFIG | base64 -d > $KUBECONFIG
    - kubectl config use-context $KUBECONTEXT
    - kubectl cluster-info
  script:
    # Wait for SQL Server to be ready
    - echo "Waiting for SQL Server to be ready..."
    - kubectl wait --for=condition=ready pod -l app=mssql -n $KUBE_NAMESPACE --timeout=300s

    # Get the SQL Server pod name
    - MSSQL_POD=$(kubectl get pods -l app=mssql -n $KUBE_NAMESPACE -o jsonpath='{.items[0].metadata.name}')
    - echo "SQL Server pod:" $MSSQL_POD

    # Test connection first (using the correct sqlcmd path for SQL Server 2022)
    - kubectl exec $MSSQL_POD -n $KUBE_NAMESPACE -- /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P "$MSSQL_PASSWORD" -Q "SELECT @@VERSION" -C
    
    # Create database if not exists
    - |
      kubectl exec $MSSQL_POD -n $KUBE_NAMESPACE -- /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P "$MSSQL_PASSWORD" -C -Q "
      IF NOT EXISTS (SELECT name FROM sys.databases WHERE name = '$MSSQL_DB')
      BEGIN
          CREATE DATABASE [$MSSQL_DB];
          PRINT 'Database $MSSQL_DB created successfully.';
      END
      ELSE
      BEGIN
          PRINT 'Database $MSSQL_DB already exists.';
      END"
    
    # Verify database creation
    - kubectl exec $MSSQL_POD -n $KUBE_NAMESPACE -- /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P "$MSSQL_PASSWORD" -Q "SELECT name FROM sys.databases WHERE name = '$MSSQL_DB';" -C
  environment:
    name: $KUBE_NAMESPACE
  when: manual
  only:
    - main
  needs: []

# Database Migration with EF Core
migrate_database:
  stage: database
  image: bitnami/kubectl:latest
  before_script:
    - echo $KUBE_CONFIG | base64 -d > $KUBECONFIG
    - kubectl config use-context $KUBECONTEXT
    - kubectl cluster-info
  script:
    - echo "Waiting for services to be ready..."
    - kubectl wait --for=condition=ready pod -l app=mssql -n $KUBE_NAMESPACE --timeout=300s
    - kubectl wait --for=condition=ready pod -l app=aspnet-app -n $KUBE_NAMESPACE --timeout=300s
    - ASPNET_POD=$(kubectl get pods -l app=aspnet-app -n $KUBE_NAMESPACE -o jsonpath='{.items[0].metadata.name}')
    - echo "Found ASP.NET pod"
    - echo $ASPNET_POD
    - echo "Running EF Core migrations..."
    - kubectl exec $ASPNET_POD -n $KUBE_NAMESPACE -- dotnet ef database update --connection "Server=mssql-service,1433;Database=Ecommerce;User Id=sa;Password=$MSSQL_PASSWORD;TrustServerCertificate=True;Encrypt=True;" --verbose
    - echo "Migration completed successfully!"
  when: manual
  only:
    - main
  environment:
    name: $KUBE_NAMESPACE
  needs:
    - setup_database

# # Deploy to Kubernetes
# deploy_production:
#   stage: deploy
#   image: bitnami/kubectl:latest
#   before_script:
#     - echo $KUBE_CONFIG | base64 -d > $KUBECONFIG
#     - kubectl config use-context $KUBECONTEXT
#   script:
#     # Update image tag in ArgoCD application manifest
#     - kubectl patch application aspnet-ecommerce -n argocd --type='merge' -p='{"spec":{"source":{"helm":{"parameters":[{"name":"image.repository","value":"'$CI_REGISTRY_IMAGE'"},{"name":"image.tag","value":"'$CI_COMMIT_SHA'"}]}}}}'
    
#     # Trigger ArgoCD sync (optional - ArgoCD can auto-sync)
#     - kubectl patch application aspnet-ecommerce -n argocd --type='merge' -p='{"operation":{"sync":{"revision":"HEAD"}}}'
    
#     # Wait for sync to complete
#     - kubectl wait --for=condition=Synced application/aspnet-ecommerce -n argocd --timeout=300s
    
#     # Verify deployment in $KUBE_NAMESPACE namespace
#     - kubectl get pods -n $KUBE_NAMESPACE -l app=aspnet-app

#     # Check TLS certificate status
#     - kubectl get certificate -n $KUBE_NAMESPACE
#     - kubectl describe certificate aspnet-tls-secret -n $KUBE_NAMESPACE

#     # Display service URLs
#     - echo "ðŸ“± API Base URL: https://$DOMAIN"
#     - echo "ðŸ“– Swagger UI: https://$DOMAIN/swagger"
#     - echo "ðŸ”’ TLS Certificate: $(kubectl get certificate aspnet-tls-secret -n $KUBE_NAMESPACE -o jsonpath='{.status.conditions[0].status}')"
#   environment:
#     name: $KUBE_NAMESPACE
#     url: https://$DOMAIN
#   when: manual
#   only:
#     - main