# .gitlab-ci.yml
variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  KUBECONTEXT: "gke_theta-moment-469209-j0_asia-southeast1_autopilot-cluster-1"
  KUBE_NAMESPACE: "production"
  DOMAIN: "ecommerceapi.bunlong.site"
  # GKE Configuration
  GCP_PROJECT_ID: "theta-moment-469209-j0"
  GKE_CLUSTER_NAME: "autopilot-cluster-1"
  GKE_CLUSTER_ZONE: "asia-southeast1"
  # Email API Key
  EMAIL_FROMEMAIL: "sendgrid@bunlong.site"

  # DigitalOcean Configuration
  DROPLET_IP: "188.166.219.244"
  SSH_USER: "root"
  DO_CLUSTER_NAME: "kube-node-1"
  # Kubernetes Configuration
  KUBECONFIG: "/tmp/kubeconfig"
  # Tool Versions
  DOCTL_VERSION: "1.101.0"
  KUBECTL_VERSION: "1.29.0"

stages:
  - build
  - infrastructure
  - deploy

# Build and Push Docker Image
build:
  stage: build
  image: docker:28.3.3
  services:
    - docker:28.3.3-dind
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - echo "SENDGRID_API_KEY = $EMAIL_API"
    - echo "SENDGRID_FROMEMAIL = $EMAIL_FROMEMAIL"
    # Install Python3 in the docker image
    # - apk add --no-cache python3
    # # Export the connection string as environment variable
    - export CONNECTION_STRING_B64=$(echo -n "Server=$SQLSERVER_IP,1433;Database=Ecommerce;User Id=sa;Password=$SQLSERVER_PASSWORD;TrustServerCertificate=True" | base64)
    - echo "✅ CONNECTION_STRING_B64 generated (length -- ${#CONNECTION_STRING_B64})"
  script:
    # Update appsettings.json with production connection string
    - sed -i "s|Server=<server>|Server=$SQLSERVER_IP,1433;Database=Ecommerce;User Id=sa;Password=$SQLSERVER_PASSWORD;TrustServerCertificate=True|g" appsettings.json

    # Update MongoDB connection string to use the internal Kubernetes service
    - sed -i "s|mongodb+srv://<mongodb_user>|mongodb://admin:$MONGO_PASSWORD@mongodb-service.production.svc.cluster.local:27017/MongoDB?authSource=admin|g" appsettings.json

    - sed -i "s|SendGrid_API_Key|$EMAIL_API|g" appsettings.json
    - sed -i "s|SendGrid_FromEmail|$EMAIL_FROMEMAIL|g" appsettings.json

    - sed -i "s|<Credential-cloud-storage>|$CREDENTIAL_CLOUD_STORAGE|g" appsettings.json

    - sed -i "s|ecommercevue.bunlong.site|ecommercevue.bunlong.site|g" Program.cs
    - sed -i "s|ecommerceapi.bunlong.site|ecommerceapi.bunlong.site|g" Program.cs

    # Verify the connection string was updated
    - echo "=== Checking Sensitive Variables ==="
    - |
      if [ -n "$EMAIL_API" ]; then
        echo "✅ EMAIL_API is set (length: ${#EMAIL_API})"
      else
        echo "❌ EMAIL_API is not set"
      fi

    - |
      if [ -n "$CREDENTIAL_CLOUD_STORAGE" ]; then
        echo "✅ CREDENTIAL_CLOUD_STORAGE is set (length: ${#CREDENTIAL_CLOUD_STORAGE})"
      else
        echo "❌ CREDENTIAL_CLOUD_STORAGE is not set"
      fi

    - echo "=== Checking appsettings.json ==="
    - cat appsettings.json

    # . at then end: is used the current directory to look for the Dockerfile...
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA -t $CI_REGISTRY_IMAGE:latest .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
  only:
    - main
    - develop

# Deploy app & database to GKE using kubectl & ArgoCD
# deploy:
#   stage: deploy
#   image: google/cloud-sdk:alpine
#   before_script:
#     # Decode base64 and create temporary JSON file
#     - echo $GCP_SERVICE_ACCOUNT_KEY | base64 -d > /tmp/gcp-key.json
#     # Authenticate gcloud CLI with the service account
#     - gcloud auth activate-service-account --key-file /tmp/gcp-key.json
#     # Set the GCP project context, [MASK] from GitLab Variables
#     - gcloud config set project $GCP_PROJECT_ID
#     # Get GKE cluster credentials for kubectl
#     - gcloud container clusters get-credentials $GKE_CLUSTER_NAME --zone $GKE_CLUSTER_ZONE
#     # Install kubectl if not already available in the image
#     - gcloud components install kubectl
#     # Download and setup kubectl binary, version v1.34.1 is released September 9, 2025
#     # - curl -sSL -o /usr/local/bin/kubectl https://dl.k8s.io/release/v1.34.1/bin/linux/amd64/kubectl
#     # - chmod +x /usr/local/bin/kubectl
#   script:
#     # Create namespace if it doesn't exist
#     - kubectl create namespace production --dry-run=client -o yaml | kubectl apply -f -

#     # Apply ArgoCD app & DB manifests for deployment
#     - kubectl apply -f Deploy/k8s/argocd/app
#     - kubectl apply -f Deploy/k8s/argocd/db

#     # Optionally, trigger sync immediately; -n argocd: namespace where ArgoCD is installed, use for store metadata of db & application, but actual build is in production namespace
#     - |
#       if kubectl get application sql-server -n argocd >/dev/null 2>&1; then
#         kubectl patch application sql-server -n argocd --type merge -p '{"operation":{"sync":{"syncStrategy":{"sync":{}}}}}' || true
#       fi
#     - |
#       if kubectl get application aspnet-ecommerce -n argocd >/dev/null 2>&1; then
#         kubectl patch application aspnet-ecommerce -n argocd --type merge -p '{"operation":{"sync":{"syncStrategy":{"sync":{}}}}}' || true
#       fi
#     - |
#       if kubectl get application mongodb -n argocd >/dev/null 2>&1; then
#         kubectl patch application mongodb -n argocd --type merge -p '{"operation":{"sync":{"syncStrategy":{"sync":{}}}}}' || true
#       fi
#   when: manual
#   only:
#     - main
#     - develop


# Configure Traefik for TCP ports (SQL Server & MongoDB) - Using Alpine
infrastructure:
  stage: infrastructure
  image: alpine:3.19
  before_script:
    # Install required packages
    - apk add --no-cache curl tar openssh-client bash

    # Install doctl
    - echo "=== Installing doctl v${DOCTL_VERSION} ==="
    - curl -sL https://github.com/digitalocean/doctl/releases/download/v${DOCTL_VERSION}/doctl-${DOCTL_VERSION}-linux-amd64.tar.gz | tar -xzv
    - mv doctl /usr/local/bin/
    - doctl version

    # Install kubectl
    - echo "=== Installing kubectl v${KUBECTL_VERSION} ==="
    - curl -LO "https://dl.k8s.io/release/v${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
    - chmod +x kubectl
    - mv kubectl /usr/local/bin/
    - kubectl version --client

    # Setup SSH for k3s access
    - echo "=== Setting up SSH connection ==="
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | base64 -d > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $DROPLET_IP >> ~/.ssh/known_hosts 2>/dev/null

    # Get kubeconfig from k3s droplet
    - echo "=== Fetching kubeconfig from k3s ==="
    - ssh -o StrictHostKeyChecking=no $SSH_USER@$DROPLET_IP "cat /etc/rancher/k3s/k3s.yaml" | sed "s/127.0.0.1/$DROPLET_IP/g" > $KUBECONFIG
    - chmod 600 $KUBECONFIG
    - export KUBECONFIG=$KUBECONFIG

    # Verify connection to k3s cluster
    - echo "=== Verifying k3s cluster connection ==="
    - kubectl cluster-info
    - kubectl get nodes

  script:
    - echo "=== Configuring Traefik for TCP Entrypoints ==="
    
    # Apply Traefik configuration for TCP ports
    - kubectl apply -f Deploy/k8s/traefik/traefik-config.yaml
    
    # Wait for Traefik to pick up the configuration
    - echo "Waiting for Traefik to apply configuration..."
    - sleep 10
    
    # Restart Traefik to apply new entrypoints
    - echo "=== Restarting Traefik ==="
    - |
      if kubectl get deployment traefik -n kube-system >/dev/null 2>&1; then
        kubectl rollout restart deployment traefik -n kube-system
        kubectl rollout status deployment traefik -n kube-system --timeout=120s
      elif kubectl get daemonset traefik -n kube-system >/dev/null 2>&1; then
        kubectl rollout restart daemonset traefik -n kube-system
        kubectl rollout status daemonset traefik -n kube-system --timeout=120s
      else
        echo "Traefik not found as deployment or daemonset, checking pods..."
        kubectl get pods -n kube-system -l app. kubernetes.io/name=traefik
      fi
    
    # Verify Traefik is running
    - echo "=== Traefik Status ==="
    - kubectl get pods -n kube-system -l app. kubernetes.io/name=traefik
    
    # Verify entrypoints are configured
    - echo "=== Traefik Service Ports ==="
    - kubectl get svc traefik -n kube-system -o yaml | grep -A 30 "ports:" || kubectl get svc -n kube-system | grep traefik

  when: manual
  only:
    - main
    - develop

# Deploy app & database to k3s using kubectl & ArgoCD - Using Alpine
deploy:
  stage: deploy
  image: alpine:3.19
  variables:
    KUBECONFIG: "/tmp/kubeconfig"
  before_script:
    # Install required packages
    - apk add --no-cache curl tar openssh-client bash

    # Install doctl (optional, for DigitalOcean API access)
    - echo "=== Installing doctl v${DOCTL_VERSION} ==="
    - curl -sL https://github.com/digitalocean/doctl/releases/download/v${DOCTL_VERSION}/doctl-${DOCTL_VERSION}-linux-amd64.tar.gz | tar -xzv
    - mv doctl /usr/local/bin/
    - doctl version

    # Install kubectl
    - echo "=== Installing kubectl v${KUBECTL_VERSION} ==="
    - curl -LO "https://dl.k8s.io/release/v${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
    - chmod +x kubectl
    - mv kubectl /usr/local/bin/
    - kubectl version --client

    # Setup SSH for k3s access
    - echo "=== Setting up SSH connection ==="
    - mkdir -p ~/.ssh
    - echo "$SSH_PRIVATE_KEY" | base64 -d > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $DROPLET_IP >> ~/.ssh/known_hosts 2>/dev/null

    # Get kubeconfig from k3s droplet
    - echo "=== Fetching kubeconfig from k3s ==="
    - ssh -o StrictHostKeyChecking=no $SSH_USER@$DROPLET_IP "cat /etc/rancher/k3s/k3s.yaml" | sed "s/127.0.0.1/$DROPLET_IP/g" > $KUBECONFIG
    - chmod 600 $KUBECONFIG
    - export KUBECONFIG=$KUBECONFIG

    # Verify connection to k3s cluster
    - echo "=== Verifying k3s cluster connection ==="
    - kubectl cluster-info
    - kubectl get nodes

  script:
    - echo "=== Starting Deployment to k3s ==="

    # Create namespace if it doesn't exist
    - kubectl create namespace production --dry-run=client -o yaml | kubectl apply -f -
    
    # Create namespace for argocd if it doesn't exist
    - kubectl create namespace argocd --dry-run=client -o yaml | kubectl apply -f -

    # Apply ArgoCD app & DB manifests for deployment
    - echo "=== Applying ArgoCD Application Manifests ==="
    - kubectl apply -f Deploy/k8s/argocd/app
    - kubectl apply -f Deploy/k8s/argocd/db

    # Wait for applications to be created
    - sleep 5

    # Trigger ArgoCD sync for SQL Server
    - echo "=== Syncing ArgoCD Applications ==="
    - |
      if kubectl get application sql-server -n argocd >/dev/null 2>&1; then
        echo "Syncing sql-server application..."
        kubectl patch application sql-server -n argocd --type merge -p '{"operation":{"sync":{"syncStrategy":{"apply":{"force":true}}}}}' || true
      else
        echo "sql-server application not found, skipping sync"
      fi

    # Trigger ArgoCD sync for ASP.NET app
    - |
      if kubectl get application aspnet-ecommerce -n argocd >/dev/null 2>&1; then
        echo "Syncing aspnet-ecommerce application..."
        kubectl patch application aspnet-ecommerce -n argocd --type merge -p '{"operation":{"sync":{"syncStrategy":{"apply":{"force":true}}}}}' || true
      else
        echo "aspnet-ecommerce application not found, skipping sync"
      fi

    # Trigger ArgoCD sync for MongoDB
    - |
      if kubectl get application mongodb -n argocd >/dev/null 2>&1; then
        echo "Syncing mongodb application..."
        kubectl patch application mongodb -n argocd --type merge -p '{"operation":{"sync":{"syncStrategy":{"apply":{"force":true}}}}}' || true
      else
        echo "mongodb application not found, skipping sync"
      fi

    # Display deployment status
    - echo "=== Deployment Status ==="
    - kubectl get applications -n argocd || true
    - kubectl get pods -n production
    - kubectl get svc -n production
    - kubectl get ingress -n production || true

  when: manual
  only:
    - main
    - develop