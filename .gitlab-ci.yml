# .gitlab-ci.yml
variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  # KUBECONFIG: /tmp/kubeconfig
  KUBECONTEXT: "gke_theta-moment-469209-j0_asia-southeast1_autopilot-cluster-1"
  KUBE_NAMESPACE: "production"
  DOMAIN: "ecommerceapi.bunlong.site"
  # GKE Configuration
  GCP_PROJECT_ID: "theta-moment-469209-j0"
  GKE_CLUSTER_NAME: "autopilot-cluster-1"
  GKE_CLUSTER_ZONE: "asia-southeast1"
  # Email API Key
  EMAIL_FROMEMAIL: "sendgrid@bunlong.site"

stages:
  - build
  - deploy

# Build and Push Docker Image
build:
  stage: build
  image: docker:28.3.3
  services:
    - docker:28.3.3-dind
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - echo "SENDGRID_API_KEY = $EMAIL_API"
    - echo "SENDGRID_FROMEMAIL = $EMAIL_FROMEMAIL"
  script:
    # Update appsettings.json with production connection string
    - sed -i "s|Server=<server>|Server=$SQLSERVER_IP,1433;Database=Ecommerce;User Id=sa;Password=$SQLSERVER_PASSWORD;TrustServerCertificate=True|g" appsettings.json

    - sed -i "s/<connection-string-base64>/$(echo -n "Server=$SQLSERVER_IP,1433;Database=Ecommerce;User Id=sa;Password=$SQLSERVER_PASSWORD;TrustServerCertificate=True" | base64)/g" Deploy/k8s/app/aspnet-app-deployment.yaml

    # Update MongoDB connection string to use the internal Kubernetes service
    - sed -i "s|mongodb+srv://<mongodb_user>|mongodb://admin:$MONGO_PASSWORD@mongodb-service.production.svc.cluster.local:27017/MongoDB?authSource=admin|g" appsettings.json

    - sed -i "s|SendGrid_API_Key|$EMAIL_API|g" appsettings.json
    - sed -i "s|SendGrid_FromEmail|$EMAIL_FROMEMAIL|g" appsettings.json

    - sed -i "s|<Credential-cloud-storage>|$CREDENTIAL_CLOUD_STORAGE|g" appsettings.json

    - sed -i "s|ecommercevue.bunlong.site|ecommercevue.bunlong.site|g" Program.cs
    - sed -i "s|ecommerceapi.bunlong.site|ecommerceapi.bunlong.site|g" Program.cs

    # Verify the connection string was updated
    - echo "=== Checking Sensitive Variables ==="
    - |
      if [ -n "$EMAIL_API" ]; then
        echo "✅ EMAIL_API is set (length: ${#EMAIL_API})"
      else
        echo "❌ EMAIL_API is not set"
      fi

    - |
      if [ -n "$CREDENTIAL_CLOUD_STORAGE" ]; then
        echo "✅ CREDENTIAL_CLOUD_STORAGE is set (length: ${#CREDENTIAL_CLOUD_STORAGE})"
      else
        echo "❌ CREDENTIAL_CLOUD_STORAGE is not set"
      fi

    - echo "=== Checking appsettings.json ==="
    - cat appsettings.json

    # . at then end: is used the current directory to look for the Dockerfile...
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA -t $CI_REGISTRY_IMAGE:latest .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
  only:
    - main
    - develop

# Deploy app & database to GKE using kubectl & ArgoCD
deploy:
  stage: deploy
  image: google/cloud-sdk:alpine
  before_script:
    # Decode base64 and create temporary JSON file
    - echo $GCP_SERVICE_ACCOUNT_KEY | base64 -d > /tmp/gcp-key.json
    # Authenticate gcloud CLI with the service account
    - gcloud auth activate-service-account --key-file /tmp/gcp-key.json
    # Set the GCP project context, [MASK] from GitLab Variables
    - gcloud config set project $GCP_PROJECT_ID
    # Get GKE cluster credentials for kubectl
    - gcloud container clusters get-credentials $GKE_CLUSTER_NAME --zone $GKE_CLUSTER_ZONE
    # Install kubectl if not already available in the image
    - gcloud components install kubectl
    # Download and setup kubectl binary, version v1.34.1 is released September 9, 2025
    # - curl -sSL -o /usr/local/bin/kubectl https://dl.k8s.io/release/v1.34.1/bin/linux/amd64/kubectl
    # - chmod +x /usr/local/bin/kubectl
  script:
    # Create namespace if it doesn't exist
    - kubectl create namespace production --dry-run=client -o yaml | kubectl apply -f -

    # Apply ArgoCD app & DB manifests for deployment
    - kubectl apply -f Deploy/k8s/argocd/db/
    - kubectl apply -f Deploy/k8s/argocd/app

    # Optionally, trigger sync immediately; -n argocd: namespace where ArgoCD is installed, use for store metadata of db & application, but actual build is in production namespace
    - |
      if kubectl get application sql-server -n argocd >/dev/null 2>&1; then
        kubectl patch application sql-server -n argocd --type merge -p '{"operation":{"sync":{"syncStrategy":{"sync":{}}}}}' || true
      fi
    - |
      if kubectl get application aspnet-ecommerce -n argocd >/dev/null 2>&1; then
        kubectl patch application aspnet-ecommerce -n argocd --type merge -p '{"operation":{"sync":{"syncStrategy":{"sync":{}}}}}' || true
      fi
    - |
      if kubectl get application mongodb -n argocd >/dev/null 2>&1; then
        kubectl patch application mongodb -n argocd --type merge -p '{"operation":{"sync":{"syncStrategy":{"sync":{}}}}}' || true
      fi
  when: manual
  only:
    - main
    - develop